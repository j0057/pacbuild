#!/bin/bash

set -euo pipefail

# XXX: how to deal with GPG keys?
#      for example: gpg --keyserver keys.openpgp.org --recv-keys 3A5CA953F73C700D
#      https://blog.bastelfreak.de/2016/05/creating-a-reliable-arch-linux-package-build-environment/
#      ==> okay, this took only 4 hours, but: import the fk'in key into my own gpg dir.
#          that's it. that's the whole trick. i'm going to kill a puppy now.

_msg1() { local N=$1; shift; echo -e "\e[1;36m[$N] $@\e[0m"; }
_msg2() { local N=$1; shift; echo -e "\e[1;32m[$N] $@\e[0m"; }
_msg3() { local N=$1; shift; echo -e "\e[1;31m[$N] $@\e[0m"; }

_cmd()  { local N=$1; shift; _msg1 "$N" "$@"; "$@"; }
_sudo() { local N=$1; shift; _msg2 "$N" "$@"; "$@"; }

if [ -f pacbuild.conf ]; then
    . pacbuild.conf
    : ${NAME:?NAME not set}
    : ${REPO:?REPO path not set}
    : ${ROOT:?ROOT path not set}
else
    _msg3 config 'error: no pacbuild.conf in current directory' >&2
    exit 1
fi

init_repository() {
    if [ ! -f "$REPO/$NAME.db.tar.gz" ]; then
        _cmd repo mkdir -p "$REPO"
        _cmd repo tar cfT "$REPO/$NAME.db.tar.gz" /dev/null
        _cmd repo ln -s "$NAME.db.tar.gz" "$REPO/$NAME.db"
        _sudo repo pacman -Syy
    fi
}

prepare_chroot() {
    if [ ! -d "$ROOT" ]; then
        _cmd root mkdir -p "$ROOT"
        _cmd root mkarchroot -C /etc/pacman.conf "$ROOT/root" base-devel
    fi
    _cmd root arch-nspawn "$ROOT/root" pacman -Syu
}

list_aur_packages() {
    git ls-files -s \
        | awk '$1=="160000"{print $4}'
}

get_srcinfo() {
    if [ ! -f "$1/.SRCINFO" ]; then
        (cd "$1"; makepkg --printsrcinfo >.SRCINFO)
    fi
    cat "$1/.SRCINFO"
}

get_package_version() {
    get_srcinfo "$1" \
        | awk '$1=="pkgver"{pkgver=$3}
               $1=="pkgrel"{pkgrel=$3}
               END{print pkgver "-" pkgrel}'
}

get_package_filenames() {
    get_srcinfo "$1" \
        | awk '$1=="pkgver"{pkgver=$3}
               $1=="pkgrel"{pkgrel=$3}
               $1=="arch"&&$3=="any"{arch=$3}
               /^pkgname = /{print $3 "-" pkgver "-" pkgrel "-" arch ".pkg.tar.zst"}' \
               arch="$(uname -m)"
}

package_is_up_to_date() {
    local pkgfile result
    result=0
    for pkgfile in $(get_package_filenames "$1"); do
        if [ ! -f "$REPO/$pkgfile" ]; then
            _msg1 "$1" "missing $pkgfile"
            result=1
        fi
    done
    [ $result = 0 ]
}

build_package() {
    cd "$1"
    _cmd "$1" makechrootpkg -c -r "$ROOT"
}

build_packages() {
    for pkg in $(list_aur_packages); do
        if package_is_up_to_date "$pkg"; then
            _msg2 "$pkg" "skipping: already have version $(get_package_version "$pkg")"
            continue
        fi

        _msg1 "$pkg" "building version $(get_package_version "$pkg")"
        (build_package "$pkg")

        for pkgfile in $(get_package_filenames "$pkg"); do
            _cmd "$pkg" cp "$pkg/$pkgfile" "$REPO"
            _cmd "$pkg" repo-add --new --remove "$REPO/$NAME.db.tar.gz" "$REPO/$pkgfile"
        done

        _sudo "$pkg" pacman -Syy
    done
}

clean_packages() {
    for pkg in $(list_aur_packages); do
        (cd $pkg; _cmd "$pkg" git clean -dxf)
    done
}

init_repository
prepare_chroot
build_packages
clean_packages
